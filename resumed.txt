File: .github/workflows/main.yml
""""""
# File: .github/workflows/main.yml
name: CI and Publish

# Trigger on pushes/PRs to main AND pushes of tags starting with 'v'
on:
  push:
    branches: [ "main" ]
    tags:
      - 'v*' # Trigger on tags like v0.1.0, v1.2.3, etc.
  pull_request:
    branches: [ "main" ]

jobs:
  # Job 1: Run linters, type checks, and tests
  test_and_lint:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # Test on min, max, and one intermediate Python version
        python-version: ["3.8", "3.10", "3.12"]

    steps:
    - name: Check out code
      uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip' # Cache pip dependencies

    - name: Install dependencies (including test extras)
      run: |
        python -m pip install --upgrade pip
        # Install the package with the 'test' extras defined in pyproject.toml
        pip install .[test]

    - name: Lint and Format Check with Ruff
      run: |
        ruff format --check .
        ruff check .

    - name: Analyse code with Mypy
      run: |
        # Run mypy on the source and tests directories
        mypy commitai commitai/tests

    - name: Run tests with Pytest and Coverage
      run: |
        pytest # Pytest options are configured in pyproject.toml

    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v4
      with:
        token: ${{ secrets.CODECOV_TOKEN }} # Optional: if repo is private
        slug: lguibr/commitai
        fail_ci_if_error: true

  # Job 2: Publish package to PyPI on tagged commits
  publish:
    # Only run this job if the trigger was a tag push starting with 'v'
    if: startsWith(github.ref, 'refs/tags/v')
    # Only run this job if the 'test_and_lint' job succeeded (on all Python versions)
    needs: test_and_lint
    runs-on: ubuntu-latest

    # Grant permissions for GitHub's OIDC token to be used for PyPI Trusted Publishing
    permissions:
      id-token: write # Essential for Trusted Publishing

    steps:
    - name: Check out code
      uses: actions/checkout@v4

    - name: Set up Python for publishing
      uses: actions/setup-python@v5
      with:
        python-version: '3.11' # Use a consistent Python version for building

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine # Tools needed to build and upload the package

    - name: Build package
      run: python -m build # Creates wheel and sdist in dist/ directory

    - name: Publish package to PyPI
      # Twine will automatically use the OIDC token provided by the runner environment
      # when run in a job with 'id-token: write' permissions.
      # Ensure you have configured Trusted Publishing on PyPI for this repo/workflow.
      run: twine upload dist/*
""""""


File: .gitignore
""""""

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Distribution / packaging
dist/
build/
*.egg-info/
*.egg
wheels/
*.whl

# Virtual environments
venv/
.venv/
env/
.env

# IDE files
.vscode/
.idea/

# Miscellaneous
*.log
*.swp
*.swo
*.bak
.DS_Store

# Tool Caches
.mypy_cache/
.pytest_cache/
.ruff_cache/

# Coverage
.coverage
coverage.xml
htmlcov/

# Build artifacts
commitai.egg-info/
""""""


File: .pre-commit-config.yaml
""""""

# File: .pre-commit-config.yaml
# See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0 # Use a recent version
    hooks:
      - id: check-yaml
      - id: end-of-file-fixer
      - id: trailing-whitespace
      - id: check-added-large-files

  - repo: https://github.com/astral-sh/ruff-pre-commit
    # Ruff version. Must be aligned with the version in pyproject.toml
    rev: v0.4.4 # Choose a specific Ruff version
    hooks:
      # Run the linter.
      - id: ruff
        args: [--fix, --exit-non-zero-on-fix] # Auto-fix and fail if fixes were made
      # Run the formatter.
      - id: ruff-format

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.10.0 # Use a recent version of mypy mirror
    hooks:
      - id: mypy
        # Ensure mypy runs with the necessary dependencies installed
        additional_dependencies: [
            "click>=8.0,<9.0",
            "langchain>=0.1.0,<0.3.0",
            "langchain-community>=0.0.20,<0.2.0",
            "langchain-anthropic>=0.1.0,<0.3.0",
            "langchain-openai>=0.1.0,<0.3.0",
            "langchain-google-genai~=0.0.9",
            "pydantic>=2.0,<3.0",
            "types-setuptools"
        ]
        args: [--config-file=pyproject.toml] # Point mypy to the config
        # You might need to adjust entry if your structure changes
        # entry: mypy commitai commitai/tests
""""""


File: LICENSE
""""""
# File: LICENSE
MIT License

Copyright (c) 2024 Luis Guilherme

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
""""""


File: README.md
""""""
# CommitAi - Your AI-Powered Commit Assistant

[![CI and Publish](https://github.com/lguibr/commitai/actions/workflows/main.yml/badge.svg)](https://github.com/lguibr/commitai/actions/workflows/main.yml)
[![codecov](https://codecov.io/gh/lguibr/commitai/graph/badge.svg?token=MXZKCXO6LA)](https://codecov.io/gh/lguibr/commitai) <!-- Added Codecov Badge -->
[![PyPI](https://img.shields.io/pypi/v/CommitAi.svg)](https://pypi.org/project/CommitAi/)
[![Python Version](https://img.shields.io/pypi/pyversions/CommitAi.svg)](https://pypi.org/project/CommitAi/)
[![License](https://img.shields.io/pypi/l/CommitAi.svg)](https://github.com/lguibr/CommitAi/blob/main/LICENSE)
[![Ruff](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ruff/main/assets/badge/v2.json)](https://github.com/astral-sh/ruff)

**Tired of writing Git commit messages? Let AI do the heavy lifting!**

**CommitAi** streamlines your Git workflow by leveraging powerful AI models (OpenAI's GPT, Anthropic's Claude, Google's Gemini) to automatically generate clear, concise, and conventional commit messages based on your staged changes.

Simply stage your files and run `commitai`. It analyzes the diff, optionally takes your high-level explanation, and crafts a commit message adhering to the [Conventional Commits](https://www.conventionalcommits.org/) standard. Review the message in your default Git editor, make any tweaks, save, and you're done!

## Table of Contents

- [CommitAi - Your AI-Powered Commit Assistant](#commitai---your-ai-powered-commit-assistant)
  - [Table of Contents](#table-of-contents)
  - [Features](#features)
  - [Demo](#demo)
  - [Installation](#installation)
  - [Configuration](#configuration)
    - [API Keys](#api-keys)
    - [Commit Templates (Optional)](#commit-templates-optional)
  - [Usage](#usage)
    - [Basic Workflow](#basic-workflow)
    - [Command-Line Options](#command-line-options)
    - [Creating Repository Templates](#creating-repository-templates)
  - [Examples](#examples)
  - [Contributing](#contributing)
  - [License](#license)

## Features

*   üß† **Intelligent Commit Generation**: Analyzes staged code differences (`git diff --staged`) using state-of-the-art AI models (GPT, Claude, Gemini) to create meaningful commit messages.
*   üìÑ **Conventional Commits**: Automatically formats messages according to the Conventional Commits specification (e.g., `feat(auth): add JWT authentication`). This improves readability and enables automated changelog generation.
*   üìù **Optional Explanations**: Provide a high-level description of your changes as input to guide the AI, or let it infer the context solely from the code diff.
*   ‚úÖ **Pre-commit Hook Integration**: Automatically runs your existing native Git pre-commit hook (`.git/hooks/pre-commit`) before generating the message, ensuring code quality and style checks pass.
*   üîß **Customizable Prompts via Templates**: Add custom instructions or context to the AI prompt using global environment variables or repository-specific template files.
*   ü§ñ **Multiple AI Provider Support**: Choose your preferred AI model from OpenAI, Anthropic, or Google.
*   ‚öôÔ∏è **Flexible Workflow**:
    *   Stages all changes automatically (`-a` flag).
    *   Reviews message in your default Git editor (default behavior).
    *   Commits directly without editor review (`-c` flag).
*   ‚ú® **Modern Tooling**: Built with `pyproject.toml` and formatted/linted with `ruff`.

## Demo

![CommitAi Demo](./assets/commitaai.gif)

*(Demo shows generating a commit message using Claude 3 Opus without providing an explicit explanation)*

## Installation

Ensure you have Python 3.8+ and Git installed.

Install **CommitAi** directly from PyPI:

```bash
pip install commitai
```

## Configuration

### API Keys

CommitAi requires API keys for the AI provider you intend to use. Set these as environment variables:

*   **OpenAI (GPT models):**
    ```bash
    export OPENAI_API_KEY="your_openai_api_key_here"
    ```

*   **Anthropic (Claude models):**
    ```bash
    export ANTHROPIC_API_KEY="your_anthropic_api_key_here"
    ```

*   **Google (Gemini models):**
    Set **one** of the following (CommitAi checks in this priority order):
    1.  `GOOGLE_API_KEY` (Recommended)
    2.  `GEMINI_API_KEY`
    3.  `GOOGLE_GENERATIVE_AI_API_KEY`

    Example:
    ```bash
    export GOOGLE_API_KEY="your_google_api_key_here"
    ```

You only need to set the key for the provider corresponding to the model you select (or the default, Gemini).

### Commit Templates (Optional)

You can add custom instructions to the default system prompt used by the AI. This is useful for enforcing project-specific guidelines (e.g., mentioning ticket numbers).

*   **Global Template:** Set an environment variable. This applies to all repositories unless overridden locally.
    ```bash
    # Example: Always ask the AI to reference a JIRA ticket format
    export TEMPLATE_COMMIT="Ensure the commit footer includes a JIRA reference like 'Refs: PROJECT-123'."
    ```

*   **Repository-Specific Template:** Use the `commitai-create-template` command within your repository. This creates a `.git/commit_template.txt` file and overrides the global `TEMPLATE_COMMIT` variable for this repo only.
    ```bash
    # Example: Instruct the AI to focus on UI changes for this specific repo
    commitai-create-template "Focus the commit message body on user-facing UI changes."
    ```

**Note:** These templates *add* to the default system prompt, which already instructs the AI to follow Conventional Commits format. You are providing supplementary instructions.

## Usage

### Basic Workflow

1.  **Make your code changes.**
2.  **Stage the changes** you want to include in the commit:
    ```bash
    git add <file1> <file2> ...
    # or stage all changes in tracked files
    git add .
    # or stage all changes including untracked files
    git add --all
    ```
3.  **Run `commitai`:**
    ```bash
    # Option 1: Let CommitAi infer the message from the diff
    commitai

    # Option 2: Provide a high-level explanation to guide the AI
    commitai "Refactor user authentication to use JWT tokens"
    ```
4.  **Review & Edit:** CommitAi runs pre-commit hooks, generates the message, and opens it in your default Git editor (e.g., Vim, Nano, VS Code). Review the message, make any necessary edits.
5.  **Save & Close:** Save the file and close the editor. CommitAi will then create the commit with the final message. If you close without saving or clear the message, the commit will be aborted.

### Command-Line Options

The `commitai` command (which is an alias for `commitai generate`) accepts the following options:

*   `-a`, `--add`:
    *   Automatically stages *all* unstaged changes (`git add --all`) before generating the commit message.
    *   Useful for quickly committing everything in the working directory.
    *   Example: `commitai -a "Implement user profile page"`

*   `-c`, `--commit`:
    *   Skips opening the Git editor for review. The generated message is used to create the commit directly.
    *   **Use with caution!** Reviewing AI-generated messages is recommended.
    *   Example: `commitai -c "Fix typo in documentation"` (for minor changes)
    *   Can be combined with `-a`: `commitai -a -c "Quick fix and commit all"`

*   `-m <model_name>`, `--model <model_name>`:
    *   Specifies which AI model to use.
    *   Defaults to `gemini-2.5-pro-preview-03-25`.
    *   Ensure the corresponding API key environment variable is set.
    *   Examples:
        *   `commitai -m gpt-4 "Use OpenAI's GPT-4"`
        *   `commitai -m claude-3-opus-20240229 "Use Anthropic's Claude 3 Opus"`
        *   `commitai -m gemini-2.5-flash-preview-04-17 "Use Google's Gemini 1.5 Flash"`

### Creating Repository Templates

The `commitai-create-template` command sets a repository-specific template instruction.

```bash
commitai-create-template "Add a 'Co-authored-by:' line if applicable."
```

This creates/overwrites the `.git/commit_template.txt` file in the current repository.

## Examples

**1. Simple commit, inferred message:**

```bash
# Stage changes
git add src/utils.py tests/test_utils.py

# Run commitai - AI infers message from diff
commitai
```
*(Editor opens with a message like `feat(utils): add helper function for data validation`)*

**2. Commit with explanation:**

```bash
# Stage changes
git add src/auth.py

# Run commitai with explanation
commitai "Implement password reset functionality using email tokens"
```
*(Editor opens with a message like `feat(auth): implement password reset via email token`)*

**3. Stage all and commit directly (no editor):**

```bash
# Stage all changes and commit immediately using GPT-4
commitai -a -c -m gpt-4 "Minor refactoring and cleanup"
```
*(Commit is created directly)*

**4. Using a Template:**

*   First, set a template:
    ```bash
    commitai-create-template "Mention the related issue number from GitHub, e.g., Fixes #123."
    ```
*   Then, run commitai:
    ```bash
    git add src/parser.py
    commitai "Fix bug in CSV parsing logic"
    ```
*(Editor opens with a message potentially like `fix(parser): correct handling of quoted commas\n\nFixes #123`)*

## Contributing

Contributions are highly welcome! Please follow these steps:

1.  Fork the repository on GitHub.
2.  Clone your fork locally: `git clone <your-fork-url>`
3.  Navigate to the project directory: `cd commitai`
4.  Create a virtual environment: `python -m venv .venv && source .venv/bin/activate` (or `.\.venv\Scripts\activate` on Windows)
5.  Install dependencies, including development tools: `pip install -e ".[test]"`
6.  **(Optional but Recommended)** Set up pre-commit hooks: `pre-commit install`
7.  Create a new branch for your feature or bug fix: `git checkout -b my-feature-branch`
8.  Make your changes.
9.  Run checks locally before committing:
    *   Format code: `ruff format .`
    *   Lint code: `ruff check .`
    *   Run type checks: `mypy commitai commitai/tests`
    *   Run tests: `pytest`
10. Commit your changes (you can use `commitai`!).
11. Push your branch to your fork: `git push origin my-feature-branch`
12. Open a pull request on the main `lguibr/commitai` repository.

The CI pipeline will automatically run all checks on your pull request.

## License

**CommitAi** is open-source software licensed under the MIT License. See the [LICENSE](https://github.com/lguibr/CommitAi/blob/main/LICENSE) file for more details.
""""""


File: commitai/__init__.py
""""""
# File: commitai/__init__.py
# -*- coding: utf-8 -*-

# This __version__ string is read by hatchling during the build process
# Make sure to update it for new releases.
__version__ = "0.3.0"

# The importlib.metadata approach is generally for reading the version
# of an *already installed* package at runtime. We don't need it here
# for defining the package's own version during build.
""""""


File: commitai/cli.py
""""""
# File: commitai/cli.py
# -*- coding: utf-8 -*-

import os
from typing import Optional, Tuple

import click
from langchain_anthropic import ChatAnthropic
from langchain_core.language_models.chat_models import BaseChatModel
from langchain_openai import ChatOpenAI

# Keep SecretStr import in case it's needed elsewhere or for future refinement

# Conditional import for Google Generative AI
try:
    from langchain_google_genai import ChatGoogleGenerativeAI
except ImportError:
    ChatGoogleGenerativeAI = None  # type: ignore

from commitai.git import (
    create_commit,
    get_commit_template,
    get_current_branch_name,
    get_repository_name,
    get_staged_changes_diff,
    run_pre_commit_hook,
    save_commit_template,
    stage_all_changes,
)
from commitai.template import (
    adding_template,
    build_user_message,
    default_system_message,
)


# Helper function to get API key with priority
def _get_google_api_key() -> Optional[str]:
    """Gets the Google API key from environment variables in priority order."""
    return (
        os.getenv("GOOGLE_API_KEY")
        or os.getenv("GEMINI_API_KEY")
        or os.getenv("GOOGLE_GENERATIVE_AI_API_KEY")
    )


# Helper function to initialize the LLM
def _initialize_llm(model: str) -> BaseChatModel:
    """Initializes and returns the LangChain chat model based on the model name."""
    google_api_key_str = _get_google_api_key()

    try:
        if model.startswith("gpt-"):
            api_key = os.getenv("OPENAI_API_KEY")
            if not api_key:
                raise click.ClickException(
                    "Error: OPENAI_API_KEY environment variable not set."
                )
            # Pass raw string and ignore Mypy SecretStr complaint
            return ChatOpenAI(model=model, api_key=api_key, temperature=0.7)  # type: ignore[arg-type]
        elif model.startswith("claude-"):
            api_key = os.getenv("ANTHROPIC_API_KEY")
            if not api_key:
                raise click.ClickException(
                    "Error: ANTHROPIC_API_KEY environment variable not set."
                )
            # Pass raw string and ignore Mypy SecretStr complaint
            # Also ignore missing timeout argument if it's optional
            return ChatAnthropic(model_name=model, api_key=api_key, temperature=0.7)  # type: ignore[arg-type, call-arg]
        elif model.startswith("gemini-"):
            if ChatGoogleGenerativeAI is None:
                raise click.ClickException(
                    "Error: 'langchain-google-genai' is not installed. Run 'pip install commitai[test]' or 'pip install langchain-google-genai'"
                )
            if not google_api_key_str:
                raise click.ClickException(
                    "Error: Google API Key not found. Set GOOGLE_API_KEY, GEMINI_API_KEY, or GOOGLE_GENERATIVE_AI_API_KEY."
                )
            # Pass raw string and ignore Mypy SecretStr complaint
            # Also ignore missing optional arguments
            return ChatGoogleGenerativeAI(  # type: ignore[arg-type, call-arg]
                model=model,
                google_api_key=google_api_key_str,
                temperature=0.7,
                convert_system_message_to_human=True,
            )
        else:
            raise click.ClickException(f"üö´ Unsupported model: {model}")
    except Exception as e:
        raise click.ClickException(f"Error initializing AI model: {e}") from e


# Helper function to prepare context (diff, repo, branch)
def _prepare_context() -> str:
    """Gets the repository context (name, branch, diff). Returns diff string or raises ClickException."""
    diff = get_staged_changes_diff()
    if not diff:
        raise click.ClickException("‚ö†Ô∏è Warning: No staged changes found. Exiting.")

    repo_name = get_repository_name()
    branch_name = get_current_branch_name()
    return f"{repo_name}/{branch_name}\n\n{diff}"


# Helper function to build the final prompt
def _build_prompt(
    explanation: str, formatted_diff: str, template: Optional[str]
) -> str:
    """Builds the complete prompt for the AI model."""
    system_message = default_system_message
    if template:
        system_message += adding_template
        system_message += template

    if explanation:
        diff_message = build_user_message(explanation, formatted_diff)
    else:
        diff_message = formatted_diff

    return f"{system_message}\n\n{diff_message}"


# Helper function to handle commit message editing and creation
def _handle_commit(commit_message: str, commit_flag: bool) -> None:
    """Writes message, optionally opens editor, and creates the commit. Raises ClickException on failure."""
    repo_path = get_repository_name()
    git_dir = os.path.join(repo_path, ".git")
    try:
        os.makedirs(git_dir, exist_ok=True)
    except OSError as e:
        raise click.ClickException(f"Error creating .git directory: {e}") from e

    commit_msg_path = os.path.join(git_dir, "COMMIT_EDITMSG")

    try:
        with open(commit_msg_path, "w") as f:
            f.write(commit_message)
    except IOError as e:
        raise click.ClickException(f"Error writing commit message file: {e}") from e

    final_commit_message = commit_message
    if not commit_flag:
        try:
            click.edit(filename=commit_msg_path)
            with open(commit_msg_path, "r") as f:
                final_commit_message = f.read().strip()
        except click.UsageError as e:
            click.secho(f"Could not open editor: {e}", fg="yellow")
            click.secho(f"Using generated message:\n\n{commit_message}\n", fg="yellow")
        except IOError as e:
            raise click.ClickException(
                f"Error reading commit message file after edit: {e}"
            ) from e

    if not final_commit_message:
        raise click.ClickException("Aborting commit due to empty commit message.")

    create_commit(final_commit_message)
    click.secho(
        f"\n\n‚úÖ Committed message:\n\n{final_commit_message}\n\n",
        fg="green",
        bold=True,
    )


@click.group(context_settings={"help_option_names": ["-h", "--help"]})
def cli() -> None:
    """CommitAi CLI group."""
    pass


@cli.command(name="generate")
@click.argument("description", nargs=-1, type=click.UNPROCESSED)
@click.option(
    "--commit",
    "-c",
    is_flag=True,
    help="Commit the changes with the generated message",
)
@click.option(
    "--template",
    "-t",
    default=None,
    help="Specify a commit message template (DEPRECATED: Use env var or create-template)",
)
@click.option(
    "--add",
    "-a",
    is_flag=True,
    help="Stage all changes before generating the commit message",
)
@click.option(
    "--model",
    "-m",
    default="gemini-2.5-pro-preview-03-25",
    help=(
        "Set the engine model (e.g., 'gpt-4', 'claude-3-opus-20240229', 'gemini-2.5-pro-preview-03-25'). "
        "Ensure API key env var is set (OPENAI_API_KEY, ANTHROPIC_API_KEY, GOOGLE_API_KEY/GEMINI_API_KEY/GOOGLE_GENERATIVE_AI_API_KEY)."
    ),
)
def generate_message(
    description: Tuple[str, ...],
    commit: bool,
    template: Optional[str],
    add: bool,
    model: str,
) -> None:
    """Generates a commit message based on staged changes and description."""
    explanation = " ".join(description)

    llm = _initialize_llm(model)

    if add:
        stage_all_changes()

    click.secho(
        "\nüîç Looking for a native pre-commit hook and running it\n",
        fg="blue",
        bold=True,
    )
    if not run_pre_commit_hook():
        raise click.ClickException("üö´ Pre-commit hook failed. Aborting commit.")

    formatted_diff = _prepare_context()

    if template:
        click.secho(
            "‚ö†Ô∏è Warning: The --template/-t option is deprecated. Use environment variable TEMPLATE_COMMIT or `commitai-create-template` command.",
            fg="yellow",
        )
    final_template = template or get_commit_template()

    input_message = _build_prompt(explanation, formatted_diff, final_template)

    click.clear()
    click.secho(
        "\n\nüß† Analyzing the changes and generating a commit message...\n\n",
        fg="blue",
        bold=True,
    )
    try:
        assert llm is not None
        ai_message = llm.invoke(input=input_message)
        commit_message = ai_message.content
        if not isinstance(commit_message, str):
            commit_message = str(commit_message)

    except Exception as e:
        raise click.ClickException(f"Error during AI generation: {e}") from e

    _handle_commit(commit_message, commit)


@cli.command(name="create-template")
@click.argument("template_content", nargs=-1, type=click.UNPROCESSED)
def create_template_command(template_content: Tuple[str, ...]) -> None:
    """Saves a repository-specific commit template."""
    content = " ".join(template_content)
    if content:
        save_commit_template(content)
        click.secho("üìù Template saved successfully.", fg="green")
    else:
        click.secho("‚ùó Please provide the template content.", fg="red")


# --- Alias Commands ---


@click.command(
    name="commitai",
    context_settings={"ignore_unknown_options": True},
)
@click.argument("description", nargs=-1, type=click.UNPROCESSED)
@click.option(
    "--add",
    "-a",
    is_flag=True,
    help="Stage all changes before generating the commit message",
)
@click.option(
    "--commit",
    "-c",
    is_flag=True,
    help="Commit the changes with the generated message",
)
@click.option(
    "--model",
    "-m",
    default="gemini-2.5-pro-preview-03-25",
    help="Set the engine model to be used.",
)
@click.pass_context
def commitai_alias(
    ctx: click.Context,
    description: Tuple[str, ...],
    add: bool,
    commit: bool,
    model: str,
) -> None:
    """Alias for the 'generate' command."""
    ctx.forward(
        generate_message, description=description, add=add, commit=commit, model=model
    )


@click.command(name="commitai-create-template")
@click.argument("template_content", nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def commitai_create_template_alias(
    ctx: click.Context, template_content: Tuple[str, ...]
) -> None:
    """Alias for the 'create-template' command."""
    ctx.forward(create_template_command, template_content=template_content)


cli.add_command(commitai_alias)
cli.add_command(commitai_create_template_alias)


if __name__ == "__main__":
    cli()
""""""


File: commitai/git.py
""""""
# -*- coding: utf-8 -*-
import os
import subprocess
from typing import Optional


def get_repository_name() -> str:
    return (
        subprocess.check_output(["git", "rev-parse", "--show-toplevel"])
        .strip()
        .decode()
    )


def get_current_branch_name() -> str:
    return (
        subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"])
        .strip()
        .decode()
    )


def get_staged_changes_diff() -> str:
    return subprocess.check_output(["git", "diff", "--staged"]).decode()


def stage_all_changes() -> None:
    subprocess.run(["git", "add", "--all"])


def create_commit(message: str) -> None:
    subprocess.run(["git", "commit", "-m", message])


def run_pre_commit_hook() -> bool:
    repo_path = get_repository_name()
    pre_commit_path = os.path.join(repo_path, ".git", "hooks", "pre-commit")
    if os.path.exists(pre_commit_path) and os.access(pre_commit_path, os.X_OK):
        try:
            subprocess.check_call(pre_commit_path)
            return True
        except subprocess.CalledProcessError:
            return False
    return True


def get_commit_template() -> Optional[str]:
    repo_path = get_repository_name()
    template_path = os.path.join(repo_path, ".git", "commit_template.txt")
    if os.path.exists(template_path):
        with open(template_path, "r") as f:
            return f.read()
    return os.getenv("TEMPLATE_COMMIT")


def save_commit_template(template: str) -> None:
    repo_path = get_repository_name()
    template_path = os.path.join(repo_path, ".git", "commit_template.txt")
    with open(template_path, "w") as f:
        f.write(template)
""""""


File: commitai/template.py
""""""
# -*- coding: utf-8 -*-

# flake8: noqa: E501

default_system_message = (
    "You are a helpful git commit assistant. "
    "You will receive a git diff and generate a clear, concise, and meaningful commit message."
    "The commit message should strictly follow the conventional commit format: "
    "<type>(<scope>): <subject>\n\n<body>\n\n<footer>"
    "Types can be: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert."
    "Scope is optional and represents the section of the codebase affected by the changes."
    "Subject should be a short summary of the changes, in present tense and imperative mood."
    "Body should provide more details about the changes, if necessary."
    "Footer can contain references to issues, pull requests, or breaking changes."
    "Avoid generic messages like 'update', 'fix bugs', or 'improve code'."
    "Focus on the specific changes made and their impact."
    "Don't wrap the text in the commit message, or anything like that this text is a commit message directed sent to the user editor in commit process"
)

adding_template = " The message should follow this template: "


def build_user_message(explanation, diff):
    return (
        f"Here is a high-level explanation of the commit: {explanation}" f"\n\n{diff}"
    )
""""""


File: commitai/tests/test_cli.py
""""""
# File: commitai/tests/test_cli.py
# -*- coding: utf-8 -*-
import os
from unittest.mock import MagicMock, mock_open, patch

import pytest
from click import ClickException, UsageError
from click.testing import CliRunner
from langchain_anthropic import ChatAnthropic
from langchain_google_genai import (
    ChatGoogleGenerativeAI as ActualChatGoogleGenerativeAI,
)
from langchain_openai import ChatOpenAI

from commitai.cli import cli
from commitai.template import adding_template


# Fixture to mock external dependencies for generate_message
@pytest.fixture
def mock_generate_deps(tmp_path):
    fake_repo_path = tmp_path / "fake-repo"
    fake_repo_path.mkdir()
    fake_git_dir = fake_repo_path / ".git"
    fake_commit_msg_path = str(fake_git_dir / "COMMIT_EDITMSG")
    fake_template_path = str(fake_git_dir / "commit_template.txt")

    # Use a very basic mock_open in the fixture.
    # We will configure its behavior (read_data, side_effect) within specific tests.
    mock_file_open_patch = patch("builtins.open", mock_open())

    with patch(
        "commitai.cli.ChatGoogleGenerativeAI",
        spec=ActualChatGoogleGenerativeAI,
        create=True,
    ) as mock_google_class_in_cli, patch(
        "commitai.cli.ChatOpenAI", spec=ChatOpenAI
    ) as mock_openai_class, patch(
        "commitai.cli.ChatAnthropic", spec=ChatAnthropic
    ) as mock_anthropic_class, patch(
        "commitai.cli.stage_all_changes"
    ) as mock_stage, patch(
        "commitai.cli.run_pre_commit_hook", return_value=True
    ) as mock_hook, patch(
        "commitai.cli.get_staged_changes_diff", return_value="Staged changes diff"
    ) as mock_diff, patch(
        "commitai.cli.get_repository_name", return_value=str(fake_repo_path)
    ) as mock_repo, patch(
        "commitai.cli.get_current_branch_name", return_value="main"
    ) as mock_branch, patch("commitai.cli.create_commit") as mock_commit, patch(
        "click.edit"
    ) as mock_edit, patch("click.clear"), patch(
        "commitai.cli._get_google_api_key", return_value="fake_google_key"
    ) as mock_get_google_key, patch("os.getenv") as mock_getenv, patch(
        "os.makedirs"
    ) as mock_makedirs, mock_file_open_patch as mock_builtin_open, patch(
        "os.path.exists"
    ) as mock_path_exists:
        mock_path_exists.return_value = False

        mock_openai_instance = mock_openai_class.return_value
        mock_anthropic_instance = mock_anthropic_class.return_value
        mock_google_instance = mock_google_class_in_cli.return_value

        mock_openai_instance.spec = ChatOpenAI
        mock_anthropic_instance.spec = ChatAnthropic
        if mock_google_class_in_cli is not None:
            mock_google_instance.spec = ActualChatGoogleGenerativeAI

        content_mock = MagicMock()
        content_mock.content = "Generated commit message"
        mock_openai_instance.invoke.return_value = content_mock
        mock_anthropic_instance.invoke.return_value = content_mock
        mock_google_instance.invoke.return_value = content_mock

        def getenv_side_effect(key, default=None):
            if key == "OPENAI_API_KEY":
                return "fake_openai_key"
            if key == "ANTHROPIC_API_KEY":
                return "fake_anthropic_key"
            if key == "TEMPLATE_COMMIT":
                return None
            return os.environ.get(key, default)

        mock_getenv.side_effect = getenv_side_effect

        yield {
            "openai_class": mock_openai_class,
            "anthropic_class": mock_anthropic_class,
            "google_class": mock_google_class_in_cli,
            "openai_instance": mock_openai_instance,
            "anthropic_instance": mock_anthropic_instance,
            "google_instance": mock_google_instance,
            "stage": mock_stage,
            "hook": mock_hook,
            "diff": mock_diff,
            "repo": mock_repo,
            "branch": mock_branch,
            "commit": mock_commit,
            "edit": mock_edit,
            "getenv": mock_getenv,
            "get_google_key": mock_get_google_key,
            "makedirs": mock_makedirs,
            "file_open": mock_builtin_open,  # Yield the mock_open object
            "path_exists": mock_path_exists,
            "repo_path": fake_repo_path,
            "commit_msg_path": fake_commit_msg_path,
            "template_path": fake_template_path,
        }


# --- Test generate command ---


def test_generate_default_gemini(mock_generate_deps):
    """Test the generate command defaults to gemini and no template."""
    runner = CliRunner()
    # Configure read for commit message *after* edit
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"
    mock_generate_deps["path_exists"].return_value = False
    mock_generate_deps["getenv"].side_effect = lambda k, d=None: (
        None if k == "TEMPLATE_COMMIT" else os.environ.get(k, d)
    )

    result = runner.invoke(cli, ["generate", "Test explanation"])

    assert result.exit_code == 0, result.output
    mock_generate_deps["google_class"].assert_called_once_with(
        model="gemini-2.5-pro-preview-03-25",
        google_api_key="fake_google_key",
        temperature=0.7,
        convert_system_message_to_human=True,
    )
    call_args = mock_generate_deps["google_instance"].invoke.call_args
    assert call_args is not None
    prompt = call_args.kwargs["input"]
    assert adding_template not in prompt

    mock_generate_deps["google_instance"].invoke.assert_called_once()
    commit_msg_path = mock_generate_deps["commit_msg_path"]
    # Check write call
    mock_generate_deps["file_open"].assert_any_call(commit_msg_path, "w")
    mock_generate_deps["file_open"].return_value.write.assert_called_with(
        "Generated commit message"
    )
    # Check edit call
    mock_generate_deps["edit"].assert_called_once_with(filename=commit_msg_path)
    # Check read call
    mock_generate_deps["file_open"].assert_any_call(commit_msg_path, "r")
    mock_generate_deps["file_open"].return_value.read.assert_called()
    # Check commit call
    mock_generate_deps["commit"].assert_called_once_with("Generated commit message")


def test_generate_select_gpt4(mock_generate_deps):
    """Test selecting gpt-4 model via generate command."""
    runner = CliRunner()
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"
    result = runner.invoke(cli, ["generate", "-m", "gpt-4", "Test explanation"])

    assert result.exit_code == 0, result.output
    mock_generate_deps["openai_class"].assert_called_once_with(
        model="gpt-4", api_key="fake_openai_key", temperature=0.7
    )
    mock_generate_deps["openai_instance"].invoke.assert_called_once()
    mock_generate_deps["commit"].assert_called_once()


def test_generate_select_claude(mock_generate_deps):
    """Test selecting claude model via generate command."""
    runner = CliRunner()
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"
    result = runner.invoke(
        cli, ["generate", "-m", "claude-3-opus-20240229", "Test explanation"]
    )

    assert result.exit_code == 0, result.output
    mock_generate_deps["anthropic_class"].assert_called_once_with(
        model_name="claude-3-opus-20240229",
        api_key="fake_anthropic_key",
        temperature=0.7,
    )
    mock_generate_deps["anthropic_instance"].invoke.assert_called_once()
    mock_generate_deps["commit"].assert_called_once()


def test_generate_with_add_flag(mock_generate_deps):
    """Test the -a flag with generate command."""
    runner = CliRunner()
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"
    result = runner.invoke(cli, ["generate", "-a", "Test explanation"])

    assert result.exit_code == 0, result.output
    mock_generate_deps["stage"].assert_called_once()
    mock_generate_deps["commit"].assert_called_once()


def test_generate_with_commit_flag(mock_generate_deps):
    """Test the -c flag with generate command."""
    runner = CliRunner()
    result = runner.invoke(cli, ["generate", "-c", "Test explanation"])

    assert result.exit_code == 0, result.output
    mock_generate_deps["edit"].assert_not_called()
    commit_msg_path = mock_generate_deps["commit_msg_path"]
    # Check file was opened for writing
    mock_generate_deps["file_open"].assert_called_once_with(commit_msg_path, "w")
    # Check write was called on the handle returned by mock_open
    mock_generate_deps["file_open"].return_value.write.assert_called_once_with(
        "Generated commit message"
    )
    mock_generate_deps["commit"].assert_called_once_with("Generated commit message")


def test_generate_no_staged_changes(mock_generate_deps):
    """Test generate command with no staged changes."""
    mock_generate_deps["diff"].return_value = ""
    runner = CliRunner()
    result = runner.invoke(cli, ["generate", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "Warning: No staged changes found" in result.output
    mock_generate_deps["google_class"].assert_called_once()
    mock_generate_deps["google_instance"].invoke.assert_not_called()
    mock_generate_deps["commit"].assert_not_called()


def test_generate_pre_commit_hook_fails(mock_generate_deps):
    """Test generate command when pre-commit hook fails."""
    mock_generate_deps["hook"].return_value = False
    runner = CliRunner()
    result = runner.invoke(cli, ["generate", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "Pre-commit hook failed" in result.output
    mock_generate_deps["diff"].assert_not_called()
    mock_generate_deps["commit"].assert_not_called()


def test_generate_missing_openai_key(mock_generate_deps):
    """Test generate command with missing OpenAI API key."""
    mock_generate_deps["getenv"].side_effect = lambda key, default=None: None
    runner = CliRunner()
    result = runner.invoke(cli, ["generate", "-m", "gpt-4", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "OPENAI_API_KEY environment variable not set" in result.output
    mock_generate_deps["openai_class"].assert_not_called()


def test_generate_missing_anthropic_key(mock_generate_deps):
    """Test generate command with missing Anthropic API key."""
    mock_generate_deps["getenv"].side_effect = lambda key, default=None: None
    runner = CliRunner()
    result = runner.invoke(cli, ["generate", "-m", "claude-3", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "ANTHROPIC_API_KEY environment variable not set" in result.output
    mock_generate_deps["anthropic_class"].assert_not_called()


def test_generate_missing_google_key(mock_generate_deps):
    """Test generate command with missing Google API key."""
    mock_generate_deps["get_google_key"].return_value = None
    runner = CliRunner()
    result = runner.invoke(cli, ["generate", "-m", "gemini-pro", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "Google API Key not found" in result.output
    mock_generate_deps["google_class"].assert_not_called()


def test_generate_google_key_priority(mock_generate_deps):
    """Test Google API key priority with generate command."""
    runner = CliRunner()
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"

    mock_generate_deps["get_google_key"].return_value = "genai_key"
    result = runner.invoke(cli, ["generate", "-m", "gemini-pro"])
    assert result.exit_code == 0, f"Run 1 failed: {result.output}"
    mock_generate_deps["google_class"].assert_called_with(
        model="gemini-pro",
        google_api_key="genai_key",
        temperature=0.7,
        convert_system_message_to_human=True,
    )
    mock_generate_deps["google_class"].reset_mock()
    mock_generate_deps["commit"].reset_mock()

    mock_generate_deps["get_google_key"].return_value = "gemini_key"
    result = runner.invoke(cli, ["generate", "-m", "gemini-pro"])
    assert result.exit_code == 0, f"Run 2 failed: {result.output}"
    mock_generate_deps["google_class"].assert_called_with(
        model="gemini-pro",
        google_api_key="gemini_key",
        temperature=0.7,
        convert_system_message_to_human=True,
    )
    mock_generate_deps["google_class"].reset_mock()
    mock_generate_deps["commit"].reset_mock()

    mock_generate_deps["get_google_key"].return_value = "google_key"
    result = runner.invoke(cli, ["generate", "-m", "gemini-pro"])
    assert result.exit_code == 0, f"Run 3 failed: {result.output}"
    mock_generate_deps["google_class"].assert_called_with(
        model="gemini-pro",
        google_api_key="google_key",
        temperature=0.7,
        convert_system_message_to_human=True,
    )


def test_generate_unsupported_model(mock_generate_deps):
    """Test generate command with an unsupported model."""
    runner = CliRunner()
    result = runner.invoke(
        cli, ["generate", "-m", "unsupported-model", "Test explanation"]
    )

    assert result.exit_code == 1, result.output
    assert "Unsupported model: unsupported-model" in result.output
    mock_generate_deps["commit"].assert_not_called()


def test_generate_empty_commit_message_aborts(mock_generate_deps):
    """Test generate command aborts with empty commit message after edit."""
    runner = CliRunner()
    # Simulate reading empty string after edit
    mock_generate_deps["file_open"].return_value.read.return_value = ""

    # Use catch_exceptions=True and check result.exception
    result = runner.invoke(cli, ["generate", "Test explanation"], catch_exceptions=True)

    assert isinstance(
        result.exception, ClickException
    ), f"Expected ClickException, got {result.exception}"
    assert "Aborting commit due to empty commit message" in str(result.exception)
    mock_generate_deps["commit"].assert_not_called()


def test_generate_no_explanation(mock_generate_deps):
    """Test generate command without an explanation."""
    runner = CliRunner()
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"
    result = runner.invoke(cli, ["generate"])

    assert result.exit_code == 0, result.output
    mock_generate_deps["google_instance"].invoke.assert_called_once()
    mock_generate_deps["commit"].assert_called_once()


def test_generate_with_global_template(mock_generate_deps):
    """Test generate command with a global template."""
    runner = CliRunner()
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"
    mock_generate_deps["path_exists"].return_value = False
    original_getenv = mock_generate_deps["getenv"].side_effect

    def getenv_side_effect_with_template(key, default=None):
        if key == "TEMPLATE_COMMIT":
            return "Global Template Instruction."
        return (
            original_getenv(key, default)
            if callable(original_getenv)
            else os.environ.get(key, default)
        )

    mock_generate_deps["getenv"].side_effect = getenv_side_effect_with_template

    result = runner.invoke(cli, ["generate", "Test explanation"])
    assert result.exit_code == 0, result.output
    call_args = mock_generate_deps["google_instance"].invoke.call_args
    assert call_args is not None, "invoke was not called"
    prompt = call_args.kwargs["input"]
    assert "Global Template Instruction." in prompt
    assert adding_template in prompt
    mock_generate_deps["commit"].assert_called_once()


def test_generate_with_local_template(mock_generate_deps):
    """Test generate command with a local template file."""
    runner = CliRunner()
    local_template_content = "Local Template Instruction."
    template_path = mock_generate_deps["template_path"]
    commit_msg_path = mock_generate_deps["commit_msg_path"]

    # Simulate local template file exists
    mock_generate_deps["path_exists"].side_effect = lambda p: str(p) == template_path

    # Configure mock_open to return the correct content for each path
    # Use a new mock_open instance specifically for the template read
    template_handle = mock_open(read_data=local_template_content).return_value
    commit_handle = mock_open(read_data="Generated commit message").return_value

    def mock_open_side_effect_local(path, mode="r", *args, **kwargs):
        path_str = str(path)
        if path_str == template_path and mode == "r":
            return template_handle
        elif path_str == commit_msg_path:
            # Return the specific handle for commit message read/write
            return commit_handle
        else:
            return mock_open(read_data="").return_value  # Default empty for others

    mock_generate_deps["file_open"].side_effect = mock_open_side_effect_local

    result = runner.invoke(cli, ["generate", "Test explanation"])
    assert result.exit_code == 0, result.output
    call_args = mock_generate_deps["google_instance"].invoke.call_args
    assert call_args is not None, "invoke was not called"
    prompt = call_args.kwargs["input"]
    assert (
        local_template_content in prompt
    ), f"Local template content not found in prompt:\n{prompt}"
    assert adding_template in prompt
    assert "Global Template Instruction." not in prompt
    mock_generate_deps["commit"].assert_called_once()


def test_generate_with_deprecated_template_option(mock_generate_deps):
    """Test generate command with deprecated --template option."""
    runner = CliRunner()
    mock_generate_deps[
        "file_open"
    ].return_value.read.return_value = "Generated commit message"
    mock_generate_deps["path_exists"].return_value = False
    mock_generate_deps["getenv"].side_effect = lambda k, d=None: (
        None if k == "TEMPLATE_COMMIT" else os.environ.get(k, d)
    )

    result = runner.invoke(
        cli, ["generate", "-t", "Deprecated Template", "Test explanation"]
    )

    assert result.exit_code == 0, result.output
    assert "Warning: The --template/-t option is deprecated" in result.output
    call_args = mock_generate_deps["google_instance"].invoke.call_args
    assert call_args is not None, "invoke was not called"
    prompt = call_args.kwargs["input"]
    assert "Deprecated Template" in prompt
    assert adding_template in prompt
    mock_generate_deps["commit"].assert_called_once()


def test_generate_edit_error_usage(mock_generate_deps):
    """Test generate command handling UsageError during click.edit."""
    runner = CliRunner()
    mock_generate_deps["edit"].side_effect = UsageError("Cannot find editor")

    result = runner.invoke(cli, ["generate", "Test explanation"])

    assert result.exit_code == 0, result.output
    assert "Could not open editor: Cannot find editor" in result.output
    assert "Using generated message:" in result.output
    mock_generate_deps["commit"].assert_called_once_with("Generated commit message")


def test_generate_edit_error_io(mock_generate_deps):
    """Test generate command handling IOError during reading after click.edit."""
    runner = CliRunner()
    commit_msg_path = mock_generate_deps["commit_msg_path"]

    # Configure mock_open to raise IOError when reading commit message file
    def mock_open_side_effect_io_error(path, mode="r", *args, **kwargs):
        path_str = str(path)
        if path_str == commit_msg_path and mode == "r":
            raise IOError("Read permission denied")
        elif path_str == commit_msg_path and mode == "w":
            # Allow write to succeed using a basic mock handle
            return mock_open().return_value
        else:
            return mock_open(read_data="").return_value

    mock_generate_deps["file_open"].side_effect = mock_open_side_effect_io_error

    # Use catch_exceptions=True and check result.exception
    result = runner.invoke(cli, ["generate", "Test explanation"], catch_exceptions=True)

    assert isinstance(
        result.exception, ClickException
    ), f"Expected ClickException, got {result.exception}"
    assert "Error reading commit message file after edit" in str(result.exception)
    mock_generate_deps["commit"].assert_not_called()


def test_generate_write_error_io(mock_generate_deps):
    """Test generate command handling IOError during writing COMMIT_EDITMSG."""
    runner = CliRunner()
    commit_msg_path = mock_generate_deps["commit_msg_path"]

    def write_fail_side_effect(path, mode="r", *args, **kwargs):
        if str(path) == commit_msg_path and mode == "w":
            raise IOError("Write permission denied")
        return mock_open()()  # Basic mock for other calls

    mock_generate_deps["file_open"].side_effect = write_fail_side_effect

    result = runner.invoke(cli, ["generate", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "Error writing commit message file" in result.output
    mock_generate_deps["edit"].assert_not_called()
    mock_generate_deps["commit"].assert_not_called()


@patch("commitai.cli.ChatGoogleGenerativeAI", None)
def test_generate_google_module_not_installed(mock_generate_deps):
    """Test generate command error when google module not installed."""
    runner = CliRunner()
    mock_generate_deps["google_class"] = None
    result = runner.invoke(cli, ["generate", "-m", "gemini-pro", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "'langchain-google-genai' is not installed" in result.output


def test_generate_llm_invoke_error(mock_generate_deps):
    """Test generate command handling error during llm.invoke."""
    runner = CliRunner()
    mock_generate_deps["google_instance"].invoke.side_effect = Exception("AI API Error")

    result = runner.invoke(cli, ["generate", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "Error during AI generation: AI API Error" in result.output
    mock_generate_deps["commit"].assert_not_called()


def test_generate_makedirs_error(mock_generate_deps):
    """Test generate command handling error during os.makedirs."""
    runner = CliRunner()
    mock_generate_deps["makedirs"].side_effect = OSError("Permission denied")

    result = runner.invoke(cli, ["generate", "Test explanation"])

    assert result.exit_code == 1, result.output
    assert "Error creating .git directory: Permission denied" in result.output
    mock_generate_deps["file_open"].assert_not_called()
    mock_generate_deps["commit"].assert_not_called()


# --- Test create-template command ---


def test_create_template_command():
    """Test the create-template command."""
    runner = CliRunner()
    with patch("commitai.cli.save_commit_template") as mock_save_template:
        result = runner.invoke(cli, ["create-template", "Test template content"])
        assert result.exit_code == 0, result.output
        mock_save_template.assert_called_once_with("Test template content")
        assert "Template saved successfully." in result.output


def test_create_template_command_no_content():
    """Test the create-template command with no content."""
    runner = CliRunner()
    with patch("commitai.cli.save_commit_template") as mock_save_template:
        result = runner.invoke(cli, ["create-template"])
        assert result.exit_code == 0, result.output
        mock_save_template.assert_not_called()
        assert "Please provide the template content." in result.output
""""""


File: commitai/tests/test_git.py
""""""
# -*- coding: utf-8 -*-
from unittest.mock import mock_open, patch

from commitai.git import (
    create_commit,
    get_commit_template,
    get_current_branch_name,
    get_repository_name,
    get_staged_changes_diff,
    run_pre_commit_hook,
    save_commit_template,
    stage_all_changes,
)


def test_get_repository_name():
    with patch("subprocess.check_output") as mock_check_output:
        mock_check_output.return_value = b"/path/to/repo\n"
        assert get_repository_name() == "/path/to/repo"


def test_get_current_branch_name():
    with patch("subprocess.check_output") as mock_check_output:
        mock_check_output.return_value = b"main\n"
        assert get_current_branch_name() == "main"


def test_get_staged_changes_diff():
    with patch("subprocess.check_output") as mock_check_output:
        mock_check_output.return_value = (
            b"diff --git a/file1.txt b/file1.txt"
            b"\nindex 1234567..abcdefg 100644\n"
            b"--- a/file1.txt\n+++ b/file1.txt"
            b"\n@@ -1,2 +1,2 @@\n-old content\n+new content"
        )
        expected_output = (
            "diff --git a/file1.txt b/file1.txt"
            "\nindex 1234567..abcdefg 100644\n"
            "--- a/file1.txt\n+++ b/file1.txt\n@@ -1,2 +1,2 @@"
            "\n-old content\n+new content"
        )
        assert get_staged_changes_diff() == expected_output


def test_stage_all_changes():
    with patch("subprocess.run") as mock_run:
        stage_all_changes()
        mock_run.assert_called_once_with(["git", "add", "--all"])


def test_create_commit():
    with patch("subprocess.run") as mock_run:
        create_commit("Test commit message")
        mock_run.assert_called_once_with(
            [
                "git",
                "commit",
                "-m",
                "Test commit message",
            ]
        )


def test_get_commit_template(tmpdir):
    repo_path = tmpdir.mkdir("repo")
    git_path = repo_path.mkdir(".git")
    template_path = git_path.join("commit_template.txt")
    template_path.write("Test template")

    with (
        patch("commitai.git.get_repository_name") as mock_get_repo_name,
        patch(
            "builtins.open",
            mock_open(read_data="Test template"),
            create=True,
        ),
    ):
        mock_get_repo_name.return_value = str(repo_path)
        assert get_commit_template() == "Test template"

    with (
        patch("os.getenv") as mock_getenv,
        patch(
            "builtins.open",
            mock_open(read_data="Global template"),
            create=True,
        ),
    ):
        mock_getenv.return_value = "Global template"
        assert get_commit_template() == "Global template"


def test_save_commit_template(tmpdir):
    repo_path = tmpdir.mkdir("repo")
    git_path = repo_path.mkdir(".git")

    with patch("commitai.git.get_repository_name") as mock_get_repo_name:
        mock_get_repo_name.return_value = str(repo_path)
        save_commit_template("Test template")
        template_path = git_path.join("commit_template.txt")
        assert template_path.read() == "Test template"


def test_run_pre_commit_hook(tmpdir):
    repo_path = tmpdir.mkdir("repo")
    git_path = repo_path.mkdir(".git")
    hooks_path = git_path.mkdir("hooks")
    pre_commit_path = hooks_path.join("pre-commit")
    pre_commit_path.write("#!/bin/sh\nexit 0")
    pre_commit_path.chmod(0o755)

    with patch("commitai.git.get_repository_name") as mock_get_repo_name:
        mock_get_repo_name.return_value = str(repo_path)
        assert run_pre_commit_hook() is True

    pre_commit_path.write("#!/bin/sh\nexit 1")
    with patch("commitai.git.get_repository_name") as mock_get_repo_name:
        mock_get_repo_name.return_value = str(repo_path)
        assert run_pre_commit_hook() is False
""""""


File: commitai/tests/test_template.py
""""""
# File: commitai/tests/test_template.py
# -*- coding: utf-8 -*-

from commitai.template import (
    adding_template,
    build_user_message,
    default_system_message,
)


def test_build_user_message_with_explanation():
    """Test building the user message with both explanation and diff."""
    explanation = "This is the explanation."
    diff = "--- a/file.txt\n+++ b/file.txt\n@@ -1 +1 @@\n-old\n+new"
    expected_message = (
        f"Here is a high-level explanation of the commit: {explanation}" f"\n\n{diff}"
    )
    actual_message = build_user_message(explanation, diff)
    assert actual_message == expected_message


def test_build_user_message_without_explanation():
    """Test building the user message with only the diff (empty explanation)."""
    explanation = ""
    diff = "--- a/file.txt\n+++ b/file.txt\n@@ -1 +1 @@\n-old\n+new"
    # When explanation is empty, the function should still include the prefix text
    expected_message = (
        f"Here is a high-level explanation of the commit: {explanation}" f"\n\n{diff}"
    )
    actual_message = build_user_message(explanation, diff)
    assert actual_message == expected_message


def test_default_system_message_content():
    """Test that the default system message constant exists and is a non-empty string."""
    assert isinstance(default_system_message, str)
    assert len(default_system_message) > 0
    assert "conventional commit format" in default_system_message


def test_adding_template_content():
    """Test that the adding template constant exists and is a non-empty string."""
    assert isinstance(adding_template, str)
    assert len(adding_template) > 0
    assert "follow this template" in adding_template
""""""


File: pyproject.toml
""""""
# File: pyproject.toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "commitai"
version = "0.3.0"
description = "Commitai helps you generate git commit messages using AI"
readme = "README.md"
requires-python = ">=3.8"
license = { file = "LICENSE" }
authors = [
    { name = "Luis Guilherme", email = "lgpelin92@gmail.com" },
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Software Development :: Version Control :: Git",
    "Topic :: Utilities",
]
dependencies = [
    "click>=8.0,<9.0",
    "langchain>=0.1.0,<0.3.0",
    "langchain-core>=0.1.0,<0.3.0",
    "langchain-community>=0.0.20,<0.2.0",
    "langchain-anthropic>=0.1.0,<0.3.0",
    "langchain-openai>=0.1.0,<0.3.0",
    "langchain-google-genai~=0.0.9",
    "pydantic>=2.0,<3.0",
]

[project.urls]
"Bug Tracker" = "https://github.com/lguibr/commitai/issues"
"Documentation" = "https://github.com/lguibr/commitai/blob/main/README.md"
"Source Code" = "https://github.com/lguibr/commitai"

[project.scripts]
commitai = "commitai.cli:commitai_alias"
commitai-create-template = "commitai.cli:commitai_create_template_alias"

[project.optional-dependencies]
test = [
    "pytest>=7.0",
    "pytest-cov>=3.0",
    "mypy>=1.9.0",
    "types-setuptools",
    "ruff>=0.3.0",
    "langchain-google-genai~=0.0.9",
]

[tool.hatch.version]
path = "commitai/__init__.py"

[tool.ruff]
line-length = 88
target-version = "py38"

[tool.ruff.lint]
select = [
    "E", "W", "F", "I", "C", "B", "C90", "B904", "C4", # Added B904, C4
]
ignore = ["E501"]

[tool.ruff.lint.mccabe]
max-complexity = 15

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true
files = ["commitai", "commitai/tests"]
# Ignore specific error codes globally for now
# Ideally, scope these with [[tool.mypy.overrides]] if possible later
disable_error_code = ["arg-type", "call-arg"]

[tool.pytest.ini_options]
minversion = "7.0"
addopts = "-ra -q --cov=commitai --cov-report=term-missing --cov-report=xml"
testpaths = [
    "commitai/tests",
]
[tool.coverage.report]
fail_under = 55
show_missing = true
""""""
